use tokio::process::Command;
use encoding_rs::Encoding;
use std::path::PathBuf;pub async fn execute_external_command(current_dir: &PathBuf, command_str: &str) -> String {    println!("[DEBUG] Executing external command: {}", command_str);    let (shell, shell_arg) = if cfg!(windows) {        ("cmd.exe", "/C")    } else {        ("sh", "-c")    };    let output_result = Command::new(shell)        .arg(shell_arg)        .arg(command_str)        .current_dir(current_dir)        .output()        .await;    match output_result {        Ok(output) => {            let decoder = if cfg!(windows) {                Encoding::for_label(b"windows-949").unwrap()            } else {                Encoding::for_label(b"utf-8").unwrap()            };            let (decoded_stdout, _, _) = decoder.decode(&output.stdout);            let (decoded_stderr, _, _) = decoder.decode(&output.stderr);            if !output.status.success() {                format!(                    "Command failed with exit code: {}\nStdout:\n{}\nStderr:\n{}",                    output.status.code().unwrap_or(-1),                    decoded_stdout,                    decoded_stderr                )            } else {                format!("{}{}", decoded_stdout, decoded_stderr)            }        }        Err(e) => {            format!("Error executing command: {}\n", e)        }    }}